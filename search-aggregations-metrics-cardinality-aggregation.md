## Дополнительные определния
- **Множество** - совокупность **различных** элементов, мыслимую как единое целое.
- **Мощность множества** - характеристика множеств, обобщающая понятие количества (числа) элементов конечного множества.

# Агрегация по мощности множества.

Агреация метрики с единственным значением, которая вычисляется как приблизительное значение уникальных значений. Значения могут быть извлечены либо из конкретных полей документа, либо сгенерированного скрипта.

Предположим, вы индексируете книги и хотите посчитать количество уникальных авторов по данному запросу.
```
{
    "aggs" : {
        "author_count" : {
            "cardinality" : {
                "field" : "author"
            }
        }
    }
}
```

## Контроль точности

Данная агрегация также поддерживает опцию ```precision_threshold``` (порог точности).

**Предупреждение!** Опция ```precision_threshold``` является специфичной для текущей внутренней реализации аргрегирования по мощности, которая может измениться в будущем. 

```
{
    "aggs" : {
        "author_count" : {
            "cardinality" : {
                "field" : "author_hash",
                "precision_threshold": 100 (1)
            }
        }
    }
}
```

(1) - Опция ```precision_threshold``` позволяет манипулировать памятья для определения точности и определяет насколько количество вычисляемых уникальных значений будет близко к точному значению. Above this value, counts might become a bit more fuzzy. Максимально поддерживаемое значение - 40000. При установке этого параметра больше чем 40000, эффект будет идентичен использованию значения 40000. Значение по стандарту зависит от количества родительских агрегаций, которые создаются множественными buckets (такие как ```terms``` или ```histograms```(гистограммы)).

## Итоговое значение является приблизительным
Вычисление точного значения счетчика требует загрузки значений в набор хэшей и возвращении размера набора. Этот подход не массштабируется при работе с высоко-мощными наборами и/или с большим набором значений ```as the required memory usage and the need to communicate those per-shard sets between nodes would utilize too many resources of the cluster```.

Данная агрегация по мощности основана на алгоритме [HyperLogLog++](http://static.googleusercontent.com/media/research.google.com/fr//pubs/archive/40671.pdf), который считает количество, основываясь на значения хэшей с некоторыми интересными свойствами:

- Настраиваемая точность, которая решает как много памяти необходимо потратить для точности.
- Превосходная точность на наборах с малой мощностью.
- Фиксированное использование памяти: не имеет значения имеются ли десятки, или биллионы уникальных значений, использование памяти зависит только от настройки параметра точности.

Для порога точности равное ```c```, реализация которую мы испоьзуем потребует около ```с * 8``` байт.

Следующий график показывает изменение количества ошибок с разными порогами точности:

![](https://www.elastic.co/guide/en/elasticsearch/reference/current/images/cardinality_error.png)

Для всех 3 порогов, подсчет был точным для настроенного порога (хотя не гарантировано, но скорее всего это будет так). Так же помните, что при установке параметра ниже 100, количество ошибок все равно будет меньше 5%, даже при подсчете миллиона объектов.

## Предварительно вычисленные хэши

На строковых полях, которые имеют высокую мощность, будет быстрее хранить хэши ваших значений в индексе и запускать агрегацию по мощности для этого поля. Это может быть сделано как с предосталвением значений хэшей с клиентской стороны, так и позволяя elasticsearch высчитывать значения хэшей для вас с помощью плагина [mapper-murmur3](https://www.elastic.co/guide/en/elasticsearch/plugins/2.3/mapper-size.html).

**Замечание.** Предварительно вычисляемые хэши обычно используются только на очень больших и/или полях с большим количеством полей, это позволяет сохранять CPU и память. Тем не менее, на числовых полях, процесс хэширования быстрый и хранение исходных значений требует столько же или меньше памяти, чем хранения хэшей. Также это верно и для строковых полей с маленьким количеством элементов, особенно если учесть, что они имеют оптимизацию для того, чтобы убедиться, что хэши вычисляются не более одного раза за уникальное значение на сегмент.

## Скрипты
Метрика по мощности поддерживает скрипты. При исполнении скриптов существует заметное снижение производительности, так как хэши должны быть вычислены на лету.

```
{
    "aggs" : {
        "author_count" : {
            "cardinality" : {
                "script": "doc['author.first_name'].value + ' ' + doc['author.last_name'].value"
            }
        }
    }
}
```

В данном примере интерпретируется скрипта с параметрами во встроенный скрипт с стандартным языком и без параметров скрипта. Для использования файла с скриптом, необходим следующий синтаксис:

```
{
    "aggs" : {
        "author_count" : {
            "cardinality" : {
                "script" : {
                    "file": "my_script",
                    "params": {
                        "first_name_field": "author.first_name",
                        "last_name_field": "author.last_name"
                    }
                }
            }
        }
    }
}
```

**Подсказка.** Для индексированных скриптов замените параметр ```file``` на параметр ```id```.

## Отсутствующее значение

Параметр ```missing``` определяет поведение обработки документа при отсутсвующих значениях. По стандарту, такие значения будут проигнорированы, но можно настроить поведение, как если бы они имели значение.

```
{
    "aggs" : {
        "tag_cardinality" : {
            "cardinality" : {
                "field" : "tag",
                "missing": "N/A" (1)
            }
        }
    }
}
```

(1) - Документ без значения в поле ```tag``` попадает в один и тот же bucket, со значением N/A.  
