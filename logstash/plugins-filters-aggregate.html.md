# Agregate
**NOTE**. Плагин поддерживается комьюнити. Он не поставляется c Logstash по стандарту, но его легко установить командой ```bin/plugin install logstash-filter-aggregate```.

Цель фильтра - агрегация доступных событий среди нескольких источников (обычно из строчек log-файлов), принадлежащих к одной и той же задаче, и в конечном счете отправление этих объедененных данных в финальное событие.

Вы должны быть крайней аккуратны при установке параметра количества воркеров (filter workers) в 1  (```-w 1 flag```), для того, чтобы фильтр работал корректно, в противном случае документы могут быть обработаны вне последовательности и имеется вероятность получения неожиданных результатов (имеется ввиду, что при значении 1 такого поведения не будет **прим. пер.**).

## Пример #1

С такими логами :
```
INFO - 12345 - TASK_START - start
INFO - 12345 - SQL - sqlQuery1 - 12
INFO - 12345 - SQL - sqlQuery2 - 34
INFO - 12345 - TASK_END - end
```
и такой конфигурациейвы вы можете "собрать" поле "sql duration" (продолжительность sql) для всей задачи:
```
 filter {
   grok {
     match => [ "message", "%{LOGLEVEL:loglevel} - %{NOTSPACE:taskid} - %{NOTSPACE:logger} - %{WORD:label}( - %{INT:duration:int})?" ]
   }

   if [logger] == "TASK_START" {
     aggregate {
       task_id => "%{taskid}"
       code => "map['sql_duration'] = 0"
       map_action => "create"
     }
   }

   if [logger] == "SQL" {
     aggregate {
       task_id => "%{taskid}"
       code => "map['sql_duration'] += event['duration']"
       map_action => "update"
     }
   }

   if [logger] == "TASK_END" {
     aggregate {
       task_id => "%{taskid}"
       code => "event['sql_duration'] = map['sql_duration']"
       map_action => "update"
       end_of_task => true
       timeout => 120
     }
   }
 }
```
финальный результат будет выглядеть следующим образом:
```
{
  "message" => "INFO - 12345 - TASK_END - end message",
  "sql_duration" => 46
}
```
Добавится поле ```sql_duration```, которое будет содержать продолжительность всех sql-запросов.

## Пример #2

Если у вас есть лог-файл аналогичный файлу из Примера #1, но без стартового лога (первая строка примера #1):
```
INFO - 12345 - SQL - sqlQuery1 - 12
INFO - 12345 - SQL - sqlQuery2 - 34
INFO - 12345 - TASK_END - end
```
вы можете так же "собрать" поле "sql duration" с немного измененной конфигурацией:
```
filter {
   grok {
     match => [ "message", "%{LOGLEVEL:loglevel} - %{NOTSPACE:taskid} - %{NOTSPACE:logger} - %{WORD:label}( - %{INT:duration:int})?" ]
   }

   if [logger] == "SQL" {
     aggregate {
       task_id => "%{taskid}"
       code => "map['sql_duration'] ||= 0 ; map['sql_duration'] += event['duration']"
     }
   }

   if [logger] == "TASK_END" {
     aggregate {
       task_id => "%{taskid}"
       code => "event['sql_duration'] = map['sql_duration']"
       end_of_task => true
       timeout => 120
     }
   }
 }
 ```
В конечном итоге результат получится идентичный результату из первого примера.
Здесь оператор ruby "||=" является ключевым моментом. Он позволяет инициализировать "обход" (map) поля "sql_duration", если "обход" до этого еще не был инициализирован.

## Как это работает
- Фильтру необходим "task_id" для сопоставления событий (линий в log-файле) одной и той же задачи
- В начале задачи фильтр создает "обход", привязанный к task_id
- Для каждого события вы можете выполнить код используя ```event``` и ```map``` (например скопировать поле события в "обход")
- В конце события можно запустить финальный код (например добавление информации собранной в "обходе" в конечное событие) 
- После финального события, прикрепленный к задаче "обход" удаляется.
- В конфигураций фильтра рекомендуется определить параметр таймаута, для защиты от незакрытых задач. Этот параметр помогает фильтру удалять протухшие обходы.
- По дефолту параметр таймаута установлен в значение 1800 секунд
- И последнее, если выполнение кода вызывает исключение, ошибка логируется, а событие помечается как ```_aggregateexception```

## Краткий обзор
Плагин поддерживает следующие опции:

### Обязательные опции:
```
aggregate {
    code => ...
    task_id => ...
}
```

### Доступные опции:
| Настройка      | Тип ввода | Обязательный | Дефолтное значение       |
|----------------|-----------|--------------|--------------------------|
| add_field      | hash      | Нет          | ```{}```                 |
| add_tag        | array     | Нет          | ```[]```                 |
| code           | string    | Да           |                          |
| end_of_task    | boolean   | Нет          | ```false```              |
| map_action     | string    | Нет          | ```"create_or_update"``` |
| periodic_flush | boolean   | Нет          | ```false```              |
| remove_field   | array     | Нет          | ```[]```                 |
| remove_tag     | array     | Нет          | ```[]```                 |
| task_id        | string    | Да           |                          |
| timeout        | number    | Нет          | ```0```                  |
